/*

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    device.c - Device handling events for example driver.
	           驱动程序示例的设备处理事件

Abstract:

    This is a C version of a very simple sample driver that illustrates
    how to use the driver framework and demonstrates best practices.
	这是一个非常简单的C版本驱动程序示例，它说明了如何使用驱动程序框架并演示最佳实践。

*/

#include "driver.h"

/*
Function:
    EchoDeviceCreate
    建立设备, 由EchoEvtDeviceAdd调用。

Routine Description:

	Worker routine called to create a device and its software resources.
	调用工作程序来创建设备及其软件资源。

Arguments:

	DeviceInit - Pointer to an opaque init structure. Memory for this
				 structure will be freed by the framework when the WdfDeviceCreate
				 succeeds. So don't access the structure after that point.
				 指向不透明初始化结构的指针。 WdfDeviceCreate成功后，框架将释放此结构的内存。
				 因此，在那之后不要访问结构。

Return Value:

	NTSTATUS
*/
NTSTATUS EchoDeviceCreate(PWDFDEVICE_INIT DeviceInit)
{
    KdPrint(("EchoDeviceCreate\n"));

    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    WDFDEVICE device;
    NTSTATUS status;

    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

    //
    // Register PNP/POWER callbacks so that we can start and stop the timer as the device
    // gets started and stopped.
	// 注册 PNP/POWER 回调，以便我们可以在设备启动和停止时启动和停止计时器。
    //
    pnpPowerCallbacks.EvtDeviceSelfManagedIoInit    = EchoEvtDeviceSelfManagedIoStart;
    pnpPowerCallbacks.EvtDeviceSelfManagedIoSuspend = EchoEvtDeviceSelfManagedIoSuspend;

    #pragma prefast(suppress: 28024, "Function used for both Init and Restart Callbacks")
    pnpPowerCallbacks.EvtDeviceSelfManagedIoRestart = EchoEvtDeviceSelfManagedIoStart;

    //
    // Register the pnp and power callbacks. Power policy related callbacks will be registered
    // later in SotwareInit.
	// 注册 PNP/POWER 回调。 电源策略相关的回调将稍后在SotwareInit中注册。
    //
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    KdPrint(("WdfDeviceCreate\n"));
    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get the device context and initialize it. WdfObjectGet_DEVICE_CONTEXT is an
        // inline function generated by WDF_DECLARE_CONTEXT_TYPE macro in the
        // device.h header file. This function will do the type checking and return
        // the device context. If you pass a wrong object  handle
        // it will return NULL and assert if run under framework verifier mode.
		// 获取设备上下文并对其进行初始化。 WdfObjectGet_DEVICE_CONTEXT是由device.h头文件中的WDF_DECLARE_CONTEXT_TYPE宏生成的内联函数。 
		// 该函数将进行类型检查并返回设备上下文。 如果传递了错误的对象句柄，则它将返回NULL并断言如果在框架验证程序模式下运行。
        //
        deviceContext = WdfObjectGet_DEVICE_CONTEXT(device);
        deviceContext->PrivateDeviceData = 0;

        //
        // Create a device interface so that application can find and talk to us.
		// 创建一个设备接口，以便应用程序可以找到我们并与我们交谈。
        //
        KdPrint(("WdfDeviceCreateDeviceInterface\n"));
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_ECHO,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) {
            KdPrint(("EchoQueueInitialize\n"));

            //
            // Initialize the I/O Package and any Queues
			// 初始化I/O包和任何队列
            //
            status = EchoQueueInitialize(device);
        }
    }

    return status;
}

/*
Function:
    EchoEvtDeviceSelfManagedIoStart
    设备启动回调

Routine Description:

	This event is called by the Framework when the device is started
	or restarted after a suspend operation.
	设备启动时，框架会调用此事件或在挂起操作后重新启动。

	This function is not marked pageable because this function is in the
	device power up path. When a function is marked pagable and the code
	section is paged out, it will generate a page fault which could impact
	the fast resume behavior because the client driver will have to wait
	until the system drivers can service this page fault.
	此功能未标记为可分页，因为此功能位于设备加电路径。 
	当功能标记为可分页且代码该部分已被调出，将产生页面错误，这可能会影响快速恢复行为，
	因为客户端驱动程序将不得不等待直到系统驱动程序可以解决此页面错误为止。

Arguments:

	Device - Handle to a framework device object.
	         处理框架设备对象。

Return Value:

	NTSTATUS - Failures will result in the device stack being torn down.
	           故障将导致设备堆栈被拆除。
*/
NTSTATUS EchoEvtDeviceSelfManagedIoStart(IN  WDFDEVICE Device)
{
    KdPrint(("EchoEvtDeviceSelfManagedIoStart\n"));

    PQUEUE_CONTEXT queueContext = QueueGetContext(WdfDeviceGetDefaultQueue(Device));
    LARGE_INTEGER DueTime;

    //
    // Restart the queue and the periodic timer. We stopped them before going
    // into low power state.
	// 重新启动队列和定期计时器。 进入低功耗状态之前，我们已将其停止。
    //
    KdPrint(("WdfIoQueueStart\n"));
    WdfIoQueueStart(WdfDeviceGetDefaultQueue(Device));

    DueTime.QuadPart = WDF_REL_TIMEOUT_IN_MS(100);

    KdPrint(("WdfTimerStart\n"));
    WdfTimerStart(queueContext->Timer,  DueTime.QuadPart);

    return STATUS_SUCCESS;
}

/*
Function:
    EchoEvtDeviceSelfManagedIoSuspend
    设备停止回调

Routine Description:

	This event is called by the Framework when the device is stopped
	for resource rebalance or suspended when the system is entering
	Sx state.
	设备停止时，框架会调用此事件在系统进入时进行资源重新平衡或暂停Sx状态。

Arguments:

	Device - Handle to a framework device object.
	         处理框架设备对象。

Return Value:

	NTSTATUS - The driver is not allowed to fail this function.  If it does, the
	           device stack will be torn down.
	           不允许驱动程序使此功能失败。 如果是这样，设备堆栈将被拆除。
*/
NTSTATUS EchoEvtDeviceSelfManagedIoSuspend(IN  WDFDEVICE Device)
{
    KdPrint(("EchoEvtDeviceSelfManagedIoSuspend\n"));

    PQUEUE_CONTEXT queueContext = QueueGetContext(WdfDeviceGetDefaultQueue(Device));

    PAGED_CODE();

    //
    // Before we stop the timer we should make sure there are no outstanding
    // i/o. We need to do that because framework cannot suspend the device
    // if there are requests owned by the driver. There are two ways to solve
    // this issue: 1) We can wait for the outstanding I/O to be complete by the
    // periodic timer 2) Register EvtIoStop callback on the queue and acknowledge
    // the request to inform the framework that it's okay to suspend the device
    // with outstanding I/O. In this sample we will use the 1st approach
    // because it's pretty easy to do. We will restart the queue when the
    // device is restarted.
	// 在停止计时器之前，我们应确保没有未完成的I/O。 我们需要这样做，因为如果驱动程序拥有请求，则框架无法挂起设备。
	// 有两种方法可以解决此问题：
    // 1）我们可以等待定期计时器完成未完成的I/O。
	// 2）在队列上注册EvtIoStop回调，并确认该请求以通知框架可以使用未完成的 I/O挂起设备。
	//    在此示例中，我们将使用第一种方法，因为它很容易做到。 重新启动设备后，我们将重新启动队列。
    //
    KdPrint(("WdfIoQueueStopSynchronously\n"));
    WdfIoQueueStopSynchronously(WdfDeviceGetDefaultQueue(Device));

    //
    // Stop the watchdog timer and wait for DPC to run to completion if it's already fired.
	// 停止看门狗计时器，并等待DPC运行完毕（如果已启动）。
    //
    KdPrint(("WdfTimerStop\n"));
    WdfTimerStop(queueContext->Timer, TRUE);

    return STATUS_SUCCESS;
}

